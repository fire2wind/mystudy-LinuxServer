# 3月15日

## locker.h 线程同步机制类

多线程同步，确保任一时刻只能有一个线程能进入关键代码段

具体分为三个类，都只在构造函数内抛出错误：

- locker类的操作：
  - 私有互斥锁成员变量
  - 构造函数初始化互斥锁
  - 析构函数释放互斥锁
  - 加锁和解锁
  - 获取互斥锁
- cond类的操作：
  - 私有条件变量成员变量
  - 构造函数初始化条件变量
  - 析构函数释放条件变量
  - wait和timewait
  - 唤醒一个或多个线程和唤醒所有线程
- sem类是信号量类，利用信号量进程同步：
  - 私有信号量成员变量
  - 构造函数初始化信号量
  - 析构函数释放信号量
  - wait锁上信号量，即信号量+1
  - post解锁信号量，即信号量-1

## threadpool.h 线程池类

为了更加通用，将其定义为模板类

具体实现：

- 构造函数：
  - 创建多个线程，并设定请求队列中的请求数量，这里就用到了两个私有成员变量：线程的数量和请求队列中的请求数量；
  - 用数组来存放创建出来的线程；
  - 在开发过程中有一个私有成员变量标识是否结束进程；
  - 构造函数的运行逻辑就是创建多个线程并存入数组中，再设置线程分离。
  - 创建线程时需要指定线程运行的函数（启动函数），该启动函数被设定为静态成员函数，其作用是让线程启动起来，具体的运行逻辑再放到另一个正在负责运行的函数中。
    - 注意由于启动线程运行的函数是静态的，因此只能操作静态成员变量，但我们可以在线程创建时，通过传入this指针操作类中的变量，在启动函数中再将其转换为线程池类指针，再利用该指针调用真正的运行函数（run）。
- 析构函数：
  - 析构函数删除线程数组，并设置结束进程为true
- 加入请求队列：
  - 项目中用链表来表示请求队列，该链表是私有成员；
  - 注意对请求队列操作时一定要加锁，因为请求队列被所有线程共享，这里就用到了我们自己创建的互斥锁类，因此需要一个私有成员变量互斥锁；
  - 当有请求被加入请求队列中，就表示需要处理该请求，因此传递一个信号量通知线程处理，因此有个我们自己定义的私有成员变量信号量。
- 真正的运行函数（run）：
  - 只有当线程不结束运行时才运行该函数；
  - 该函数主要就是从请求队列中取出一个请求，然后开始运行，注意需要加锁和信号量触发；
  - 主要的处理请求逻辑在 http_conn 的函数 process ，该函数是个处理请求的入口函数。

## main.cpp

main.cpp 是用来启动服务的，我们通过终端命令行输入参数启动，其所做工作如下：

1. 检测参数是否合法；

2. 有个信号处理函数，用来忽略SIGPIPE信息，防止主线程退出；

3. 创建线程池，类型为 http_conn，这个类在 http_conn.h 中，用来处理 http 请求；

4. 有个数组保存所有的客户端信息，客户端信息用 http_conn 类存储；

5. 服务端创建套接字基本流程，开启端口复用；

6. 利用epoll，创建epoll_event对象数组，将文件描述符加入 epoll 事件中；

7. 为了代码简洁，将添加文件描述符、删除文件描述符和修改文件描述符操作放到 http_conn.cpp 中，main.cpp 从外部引用。注意修改文件描述符需要重置 EPOLLONESHOT 事件

   > EPOLLONESHOT 事件:
   >
   > 即使可以使用 ET 模式，一个 socket 上的某个事件还是可能被多次触发。这在并发程序中就会引发一个问题：比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据处理的过程中，该 socket 上又有新数据可读（EPOLLIN再次被触发），此时另一个线程被唤醒来读取这些新的数据，于是就出现了两个线程同时操作一个 socket 的局面。一个 socket 连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。
   >
   > 对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其它线程是不可能有机会操作该 socket 的。但是，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕，该线程就应该立即重置这个 socket 上的 EPOLLONSHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能够被触发，进而让其它工作线程有机会继续处理这个 socket。

   - 由于我们要读取来自客户端的数据，因此在添加文件描述符的时候，要设置其为非阻塞，用一个函数去实现。

8. 死循环执行 epoll_wait，成功调用就遍历事件数组，与客户端建立连接

   1. 由于设置了连接上限，当到达上限再有客户端连接时，该连接就不能被建立，可以给客户端一个响应；
   2. 连接成功建立后，将用户信息存入之前创建的 http_conn 数组中，通过一个函数来初始化
      1. 注意端口复用；
      2. 再将该fd添加到epoll中，对其进行监听；
      3. 用户数+1。
   3. 如果产生了错误，关闭连接，依然是调用 http_conn 的函数：
      1. 在该连接 fd 有效的情况下，移除监听的事件，将该 fd 无效，用户数-1；
      2. 不要在这个函数里执行 close，removefd 中已经 close 了。
   4. 如果有读事件，执行读操作，该函数在 http_conn 中实现；
   5. 如果有写事件，执行写操作，该函数在 http_conn 中实现

## http_conn.h http请求解析类

根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机

> * 客户端发出http连接请求
> * 从状态机读取数据,更新自身状态和接收数据,传给主状态机
> * 主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取

http_conn类里的东西：

- main.cpp 中创建了一个 http_conn 数组，所有的 http_conn 对象都共用一个 epollfd（因此是个静态变量），这样可以让所有 socket 上的事件都被注册到同一个 epoll_event 上。该 epollfd 就是 main 中得到的。

- 成员变量用户的数量也是静态成员，每有一个用户连接+1即可。

- 每个连接都有一个 socket，这是私有的。

- http_conn 类保存了客户端的信息，就有了 sockaddr_in，这也是私有的。

- addfd、removefd、modfd 是对文件描述符的操作；

- init 初始化用户信息；

- close_conn 关闭连接；

- read 和 write 负责读写：

  - 需要有读写缓冲区（注意初始化），其大小为静态成员变量；需要记录读写到了什么位置，给下标标识；
  - read：循环读取客户数据，直到无数据可读或者对方关闭连接；

- process 处理请求入口函数：

  - 将处理请求的操作给 process_read 函数，生成响应的操作给 process_write 函数；
  - 该函数只负责判断请求和响应是否成功，并根据返回值对文件描述符进行操作。具体操作：没有 HTTP 请求，就修改文件描述符，监听可读事件，并退出函数；有 HTTP 请求，生成响应，修改文件描述符为可写，若响应生成失败，关闭连接。

  > ## 有限状态机
  >
  > 有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。
  >
  > 独立状态的有限状态机：
  >
  > ```c
  > STATE_MACHINT(Package _pack)
  > {
  >     PackageType _type = _pack.GetType();
  >     switch(_type)
  >     {
  >         case type_A:
  >             process_package_A(_pack);
  >             break;
  >         case type_B:
  >             process_package_B(_pack);
  >             break;
  >     }
  > }
  > ```
  >
  > 状态之间的转移需要状态机内部驱动，如
  >
  > ```c
  > STATE_MACHINT()
  > {
  >     State cur_State = type_A;
  >     while(cur_State != type_C)
  >     {
  >         PackageType _pack = getNewPackage();
  >         switch(cur_State)
  >         {
  >             case type_A:
  >                 process_package_state_A(_pack);
  >                 cur_State = type_B;
  >                 break;
  >             case type_B:
  >                 process_package_state_B(_pack);
  >                 cur_State = type_C;
  >                 break;
  >         }
  >     }
  >     
  > }
  > ```
  >
  > 对于不同的状态表示，这里用到了 enum 类型

- 由于后面还有很多成员变量，先定义一个函数用来初始化，该函数在初始化连接时被调用；

- process_read：

  - 设定状态机初始状态，同时需要一个成员变量标识主状态机当前所处状态；
  - 状态机循环判断：
    - 主状态机状态为请求体，并且从状态机请求成功
    - 或者：由于会对每一行解析（parse_line），这里就要就要判断从状态机每一行的解析结果是否成功；
  - 进入 while 循环就获取一行数据，这里使用一个成员变量标识正在解析的行（m_start_line），我们用一个函数来返回该行的起始；
    - 其实我们用了一个数组（读缓冲区）保存数据，而 HTTP 请求报文中每一行结尾有 `\r\n` ，所以 m_start_line 就是 `\n` 的下一个下标，每读一行我们都要更新该下标，那我们可以用一个成员变量（m_checked_idx）记录当前正在解析的字符的下标。
  - 接下来利用状态机，对主状态机进行状态转换：
    - 请求首行：判断请求是否错误
    - 请求头部：
      1. 判断请求是否错误
      2. 是否获得一个完整的客户请求，是就执行具体分析（do_request：获取服务器资源）
    - 请求体：
      1. 是否获得一个完整的客户请求，是对请求进行响应（do_request）
      2. 否就改变从状态机状态为行不完整（LINE_OPEN）
    - 服务器内部错误

- parse_line：解析一行数据，判断依据是 `\r\n`

  - 注意有个成员变量（m_read_idx）表示读缓冲区最后一个字节的下一个位置；
  - 注意字符串以 `\0` 结尾；
  - 遍历读缓冲区，遇到 `\r`：
    - 下一个字符是缓冲区结尾（m_read_idx），返回数据不完整；
    - 下一个字符是 `\n`，返回该行完整；
    - 否则返回行错误。
  - 遇到 `\n`：
    - 前面一个字符是 `\r` 的时候，该行才完整；
    - 否则该行不完整

- parse_request_line：

  - 解析 HTTP 请求首行，获得请求方法、目标 URL、HTTP版本，放到成员变量中。注意初始化。

  - ```c
    char *strpbrk(const char *str1, const char *str2);
    /*
    依次检验字符串s1中的字符，当被检验字符在字符串s2中也包含时，则停止检验，并返回该字符位置，空字符null不包括在内
    返回s1中第一个满足条件的字符的指针，如果没有匹配字符则返回空指针NULL。
    */
    ```

  - ```c
    char *strchr(const char *str, int c);
    /*
    在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置，如果未找到该字符则返回 NULL
    */
    ```

- parse_header：

  - 解析头部，获得主机名(host)、连接状态(Connection)、消息体长度(Content-Length)，并判断是否有消息体，有消息体需要改变状态。

  - ```c
    size_t strspn (const char *s,const char * accept);
    //返回字符串s开头连续包含字符串accept内的字符数目
    ```

- parse_content：该函数只判断消息体是否被完整读入，没有去解析消息体。

- do_request：

  - 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，如果目标文件存在、对所有用户可读，且不是目录，则使用 mmap 将其映射到内存地址 m_file_address 处，并告诉调用者获取文件成功。
  - 给客户端响应，需要将响应存储在写缓冲区中，像读缓冲区一样，也给写缓冲区一个下标标识（m_write_idx），用一个静态变量设置写缓冲区大小；
  - 客户端会请求文件，将文件路径存入数组中，该数组存放的是文件的完整路径，注意先指定文件的根目录；
  - 我们需要对文件属性进行分析（用 C 中的结构体 struct stat），如果能够返回该文件，将该文件写入映射的内存中，用 writev 函数来执行写操作，这里用 C 中的结构体（struct iovec），其指向要写入的数据的地址和数据大小，还用了一个成员变量 m_iv_count 表示被写内存块的数量，因为 writev 采用了分散写的方法。
  - 获取文件路径及其属性，判断文件的访问权限、是否是目录；通过判断则以只读方式打开文件；创建内存映射，并将该文件映射到内存中。
  - 注意打开了文件后要关闭。

- unmap：由于创建了内存映射，在使用完内存映射后要将其释放。

- process_write：根据服务器处理HTTP请求的结果，决定返回给客户端的内容。

  - 用一些字符串，根据不同的状态码，确定不同的响应信息；
  - 响应消息也有响应首行、响应头部、响应消息体，我们通过函数将它们加入响应中。可以将加入的每一行内容都写成一个函数调用。
  - 这个函数中确定了要发送的数据长度：bytes_to_send

- add_response：

  - ```c
    void va_start(va_list argptr, last_parm);
    //读取可变参数的过程其实就是在堆栈中，使用指针,遍历堆栈段中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程·
    ```

  - ```c
    int _vsnprintf(char* str, size_t size, const char* format, va_list ap);
    //将可变参数格式化输出到一个字符数组。
    ```

  - ```c
    void va_end(va_list argptr);
    //最后取完所有参数并从函数返回之前。必须调用va_end()。由此确保堆栈的正确恢复。
    //如果未正确使用va_end()，程序可能瘫痪。
    ```

- write：

  - 定义两个成员变量表示将要发送的数据（bytes_to_send，之前已定义过）和已经发送的数据（bytes_have_send）。

  - 判断 bytes_to_send 是否为 0，是 0 则表示这一次响应结束，修改监听描述符为可读，并调用初始化成员变量函数（不带参数的 init），返回；

  - 还有要发送的数据，死循环执行分散写操作，直到没有要发送的数据。

    - 注意 writev 返回 -1 和产生错误号的情况

    - writev：一次写，免除了多次系统调用或复制数据的开销。

    - ```c
      ssize_t writev(int fd, const struct iovec *iov, int cnt);
      //writev将多个数据存储在一起，将驻留在两个或更多的不连接的缓冲区中的数据一次写出去。
      //返回值：成功返回传输字节数，失败返回-1.
      ```

    - 若响应头发送完毕，修改 m_iv；

    - 若响应头没有发送完毕，修改 m_iv 为下次写数据的位置；

    - 判断数据是否全部发送出去，若没有要发送的数据了，释放创建的内存映射，修改监听事件为可读

      - 如果连接依然保持，初始化成员变量，返回 true
      - 否则返回 false。

# 3月16日

## lst_timer.h 定时检测非活跃连接

由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

> * 统一事件源
> * 基于升序链表的定时器
> * 处理非活动连接



用户数据结构（struct client_data）：保存客户端socket地址，socket文件描述符，读缓存（待后续移植），定时器类（util_timer），定时器类需要前置声明。



定时器类（util_timer）：

- 定时器类的数据结构是一个双向链表，用于指向前一个定时器和后一个定时器；
- 因为要检测非活跃连接，所以有个用户数据的成员变量；
- 定时器需要定时，所以有个超时时间，添加一个 time_t 类型的成员变量；
- 到达超时时间后需要触发函数调用，因此有个回调函数成员变量。



定时器链表类（sort_timer_lst）：升序双向链表

- add_timer：将定时器添加到链表中
  - 处理逻辑：注意链表是升序的，因此需要比较超时时间；若超时时间不小于头节点，则利用重载函数将其插入合适的位置，该重载函数是私有的。
- adjust_timer：定时器的超时时间可能会被改变，这时就要调整定时器在链表中的位置（只考虑超时时间被延长的情况）。注意这时候传进来的定时器 timer 原来是在链表中的。
  - 处理逻辑：
    1. 如果要被调整的定时器在链表尾部，或者其新的超时时间小于下一个节点的超时时间，则不需要条件
    2. 如果要被调整的定时器是链表的头节点，将其取出并重新插入链表；
    3. 如不要被调整的定时器不是链表的头节点，将其取出并找到合适的位置插入。
- del_timer：删除定时器
  - 处理逻辑：
    1. 如果链表中只有一个定时器，直接删除该节点，并将头尾置空；
    2. 如果目标定时器是链表的头节点，将头节点后移，删除目标定时器；
    3. 如果目标定时器是链表的尾节点，将尾节点前移，删除目标定时器；
    4. 目标定时器处于链表中间，改变指针间的关系，删除目标定时器。
- tick：SIGALARM 信号每次被触发就在其信号处理函数（回调函数）中执行一次 tick() 函数，以处理链表上到期任务。
  - 处理逻辑：
    - 当触发 tick 后，我们需要从链表头开始判断，直到遇到一个未超时的；
    - 因为定时器的超时时间使用的是绝对时间，所以我们可以获取当前系统时间来和定时器时间比较，判断是否超时；
    - 超时就执行回调函数，回调函数执行完后将定时器从链表中删除。注意回调函数返回的是定时器指针。



回调函数（void (\*cb_func)(client_data*)）：

- 当回调函数被调用了，就表示该连接已过期，所以回调函数的作用就是删除监听的文件描述符，并关闭连接。



工具类（Utils）：对定时器和信号进行操作

- 该类的函数有：
  
  - 初始化超时时间（init）
  
  - 对文件描述符设置非阻塞（setnonblocking）
- 向内核事件表注册读事件（addfd）
  - 处理信号（sig_handler）、添加信号捕捉（addsig）
  - 定时处理任务（timer_handler）：因为一次 alarm 调用只会引起一次SIGALARM 信号，所以我们要重新定时，以不断触发 SIGALARM信号。
  
- 成员变量：
  - 通过管道（u_pipefd）通知任务
  - 设置的超时时间（m_TIMESLOT）
  - 定时器链表（m_timer_lst）
  - 文件描述符（u_epollfd）

## main.cpp

对 main 函数进行了比较大幅的修改，添加了对定时器的操作以及信号的检测。

由于将 main 函数改成了对非活跃连接的检测，注释掉了原来的对 HTTP 请求的解析与响应，加上了对可读事件的检测及判断是否超时。

等待重构。

# 3月18日

```c
char *getcwd( char *buffer, int maxlen );
//将当前工作目录的绝对路径复制到参数buffer所指的内存空间中
```

## lst_timer.h

Utils类添加一个成员函数（show_error）用来向客户端发送连接错误信息，并关闭客户端文件描述符。

## http_conn.h

添加一个成员变量（doc_root），用于保存根目录。

对带参的 init 函数中添加一个参数 root ，表示根目录。

添加一个成员函数，用来返回存储的客户端信息的地址，这有用于后面的日志系统中。

## webserver.h

对 main.cpp 进行重构，减少 main.cpp 中的代码量

### 成员变量：

- 线程池相关：
  - 线程池：threadpool<http_coon> *m_pool
  - 线程数量：m_thread_num
- epoll相关：
  - epoll事件数组：epoll_evenct events[MAX_EVENT_NUMBER]
  - 文件描述符：m_epollfd
- 管道：
  - 创建的管道：m_pipefd[2]
- 服务端数据：
  - 绑定的端口号：m_port
  - 服务端套接字文件描述符：m_listenfd
  - 资源根目录：m_root_doc
  - http 消息的存储，用户数量：users
- 定时器：
  - 用户定时器：users_timer
  - 定时器：utils

### 成员函数：

- 构造函数：
  - 初始化用户数量和用户定时器，即 users 和 users_timer；
  - 确定请求资源根目录。
- 析构函数：关闭所有文件描述符，释放请求的数组；
- 初始化 init：暂时只有初始化线程池中的线程数量，其它参数待后续补充。
- 创建线程池 thread_pool
- 开启监听 startListen：
  - 服务端创建套接字；
  - 创建内核事件表；
  - 设置超时时间，利用创建的工具类 utils 对文件描述符进行设置，添加对信号的处理；
  - 创建管道，并对其进行设置；
  - 初始化工具类的文件描述符；
  - alarm启动定时器。
- 循环处理客户端连接情况 startLoop：
  - 设置是否超时和是否停止服务端标识，当不停止服务才循环；
  - 开启 epoll_wait 监听，返回值错误就结束，返回值正确就遍历 events 数组；
  - 如果有新客户端连接，进入处理客户端数据 dealclientdata；
  - 如果 events 数组中的事件发送错误，服务器关闭该连接，并移除对应的定时器，即进入 deal_timer 函数；
  - **如果管道描述符收到信号**，并且 epoll 监听到可读事件，说明服务器出现错误，进入处理信号函数 dealwithsignal；
  - 剩下的就是处理客户端连接上可读事件 dealwithread 和可写事件 dealwithwrite；
  - events 数组变量完毕，若出现超时（timeout），调用工具类的 timer_handler，重新设置超时时间为 false；
- 处理新连接的客户端 dealclientdata：
  - 建立套接字，接收 accept 的返回值；
  - 若 accept 返回值小于0，返回 false；
  - 若当前连接数大于等于最大连接数，进入 show_error 函数并返回 false；
  - 成功建立连接就为该客户端设置超时时间，即进入 timer 函数。
- 对客户端文件描述符设置定时器 timer：
  - 初始化client_data数据；
  - 创建定时器；
  - 绑定用户数据；
  - 设置回调函数；
  - 设置超时时间；
  - 将定时器添加到链表中
- 关闭连接并删除定时器 deal_timer：
  - 调用了回调函数用来关闭连接；
  - 如果该连接有定时器，调用 Utils 中的 del_timer 删除定时器。
- 处理信号函数 dealwithsignal：
  - 创建一个数组，将从管道中接收到（recv）的信号存入其中；
  - 如果 recv 出错或没有读到数据，返回false；
  - 否则对信号进行判断和处理，主要为 SIGALRM 和 SIGTERM，分别对 timeout 和 stop_server 进行更改。
- 处理可读事件 dealwithread：
  - 获取当前文件描述符的定时器；
  - 先只采用模拟proactor模式，对当前用户的文件描述符调用 http_conn 的 read 函数；
  - 若读到数据（read返回true），将该事件加入请求队列（append）；
  - 存在 timer 定时器则调用 adjust_timer ；
  - webserver.h 添加了一个成员函数 adjust_timer，该函数的作用就是将当前定时器的超时时间重置，再调用 utils 的 adjust_timer 函数；
  - 若没读到数据，调用 deal_timer 函数；
- 处理可写事件：
  - 获取当前文件描述符的定时器；
  - 先只采用模拟proactor模式，对当前用户的文件描述符调用 http_conn 的 write 函数；
  - 若成功写入数据（write返回true），存在 timer 定时器则调用 adjust_timer；
  - 写入数据失败，调用 deal_timer；



程序可以正常运行，出现点问题，待改进