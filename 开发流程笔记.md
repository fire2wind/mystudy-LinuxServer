# locker.h 线程同步机制类

多线程同步，确保任一时刻只能有一个线程能进入关键代码段

具体分为三个类，都只在构造函数内抛出错误：

- locker类的操作：
  - 私有互斥锁成员变量
  - 构造函数初始化互斥锁
  - 析构函数释放互斥锁
  - 加锁和解锁
  - 获取互斥锁
- cond类的操作：
  - 私有条件变量成员变量
  - 构造函数初始化条件变量
  - 析构函数释放条件变量
  - wait和timewait
  - 唤醒一个或多个线程和唤醒所有线程
- sem类是信号量类，利用信号量进程同步：
  - 私有信号量成员变量
  - 构造函数初始化信号量
  - 析构函数释放信号量
  - wait锁上信号量，即信号量+1
  - post解锁信号量，即信号量-1

# threadpool.h 线程池类

使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。

> * 同步I/O模拟proactor模式
> * 半同步/半反应堆
> * 线程池

为了更加通用，将其定义为模板类

具体实现：

- 构造函数：
  - 创建多个线程，并设定请求队列中的请求数量，这里就用到了两个私有成员变量：线程的数量和请求队列中的请求数量；
  - 用数组来存放创建出来的线程；
  - 在开发过程中有一个私有成员变量标识是否结束进程；
  - 构造函数的运行逻辑就是创建多个线程并存入数组中，再设置线程分离。
  - 创建线程时需要指定线程运行的函数（启动函数），该启动函数被设定为静态成员函数，其作用是让线程启动起来，具体的运行逻辑再放到另一个正在负责运行的函数中。
    - 注意由于启动线程运行的函数是静态的，因此只能操作静态成员变量，但我们可以在线程创建时，通过传入this指针操作类中的变量，在启动函数中再将其转换为线程池类指针，再利用该指针调用真正的运行函数（run）。
- 析构函数：
  - 析构函数删除线程数组，并设置结束进程为true
- 加入请求队列：
  - 项目中用链表来表示请求队列，该链表是私有成员；
  - 注意对请求队列操作时一定要加锁，因为请求队列被所有线程共享，这里就用到了我们自己创建的互斥锁类，因此需要一个私有成员变量互斥锁；
  - 当有请求被加入请求队列中，就表示需要处理该请求，因此传递一个信号量通知线程处理，因此有个我们自己定义的私有成员变量信号量。
- 真正的运行函数（run）：
  - 只有当线程不结束运行时才运行该函数；
  - 该函数主要就是从请求队列中取出一个请求，然后开始运行，注意需要加锁和信号量触发；
  - 注意主要的处理请求逻辑在 http_conn 的函数 process ，该函数是个处理请求的入口函数。

# main.cpp

main.cpp 是用来启动服务的，我们通过终端命令行输入参数启动，其所做工作如下：

1. 检测参数是否合法；

2. 有个信号处理函数，用来忽略SIGPIPE信息，防止主线程退出；

3. 创建线程池，类型为 http_conn，这个类在 http_conn.h 中，用来处理 http 请求；

4. 有个数组保存所有的客户端信息，客户端信息用存储在 http_conn 类存储；

5. 服务端创建套接字基本流程，注意端口复用；

6. 利用epoll，创建epoll_event对象数组，将文件描述符加入 epoll 事件中；

7. 为了代码简洁，将添加文件描述符、删除文件描述符和修改文件描述符操作放到 http_conn.cpp 中，main.cpp 从外部引用。注意修改文件描述符需要重置 EPOLLONESHOT 事件

   > EPOLLONESHOT 事件:
   >
   > 即使可以使用 ET 模式，一个 socket 上的某个事件还是可能被多次触发。这在并发程序中就会引发一个问题：比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据处理的过程中，该 socket 上又有新数据可读（EPOLLIN再次被触发），此时另一个线程被唤醒来读取这些新的数据，于是就出现了两个线程同时操作一个 socket 的局面。一个 socket 连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。
   >
   > 对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其它线程是不可能有机会操作该 socket 的。但是，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕，该线程就应该立即重置这个 socket 上的 EPOLLONSHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能够被触发，进而让其它工作线程有机会继续处理这个 socket。

   - 由于我们要读取来自客户端的数据，因此在添加文件描述符的时候，要设置其为非阻塞，用一个函数去实现。

8. 死循环执行 epoll_wait，成功调用就遍历事件数组，与客户端建立连接

   1. 由于设置了连接上限，当到达上限再有客户端连接时，该连接就不能被建立，可以给客户端一个响应；
   2. 连接成功建立后，将用户信息存入之前创建的 http_conn 数组中，通过一个函数来初始化
      1. 注意端口复用；
      2. 再将该fd添加到epoll中，对其进行监听；
      3. 用户数+1。
   3. 如果产生了错误，关闭连接，依然是调用 http_conn 的函数：
      1. 在该连接 fd 有效的情况下，移除监听的事件，将该 fd 无效，用户数-1；
      2. 不要在这个函数里执行 close，removefd 中已经 close 了。
   4. 如果有读事件，执行读操作，该函数在 http_conn 中实现；
   5. 如果有写事件，执行写操作，该函数在 http_conn 中实现

# http_conn.h http请求解析类

根据状态转移,通过主从状态机封装了http连接类。其中,主状态机在内部调用从状态机,从状态机将处理状态和数据传给主状态机

> * 客户端发出http连接请求
> * 从状态机读取数据,更新自身状态和接收数据,传给主状态机
> * 主状态机根据从状态机状态,更新自身状态,决定响应请求还是继续读取

http_conn类里的东西：

- main.cpp 中创建了一个 http_conn 数组，所有的 http_conn 对象都共用一个 epollfd（因此是个静态变量），这样可以让所有 socket 上的事件都被注册到同一个 epoll_event 上。该 epollfd 就是 main 中得到的。

- 成员变量用户的数量也是静态成员，每有一个用户连接+1即可。

- 每个连接都有一个 socket，这是私有的。

- http_conn 类保存了客户端的信息，就有了 sockaddr_in，这也是私有的。

- addfd、removefd、modfd 是对文件描述符的操作；

- init 初始化用户信息；

- close_conn 关闭连接；

- read 和 write 负责读写：

  - 需要有读写缓冲区（注意初始化），其大小为静态成员变量；需要记录读写到了什么位置，给下标标识；
  - read：循环读取客户数据，直到无数据可读或者对方关闭连接；

- process 处理请求入口函数：

  - 将处理请求的操作给 process_read 函数，生成响应的操作给 process_write 函数；
  - 该函数只负责判断请求和响应是否成功，并根据返回值对文件描述符进行操作。具体操作：没有 HTTP 请求，就修改文件描述符，监听可读事件，并退出函数；有 HTTP 请求，生成响应，修改文件描述符为可写，若响应生成失败，关闭连接。

  > ## 有限状态机
  >
  > 有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。
  >
  > 独立状态的有限状态机：
  >
  > ```c
  > STATE_MACHINT(Package _pack)
  > {
  >     PackageType _type = _pack.GetType();
  >     switch(_type)
  >     {
  >         case type_A:
  >             process_package_A(_pack);
  >             break;
  >         case type_B:
  >             process_package_B(_pack);
  >             break;
  >     }
  > }
  > ```
  >
  > 状态之间的转移需要状态机内部驱动，如
  >
  > ```c
  > STATE_MACHINT()
  > {
  >     State cur_State = type_A;
  >     while(cur_State != type_C)
  >     {
  >         PackageType _pack = getNewPackage();
  >         switch(cur_State)
  >         {
  >             case type_A:
  >                 process_package_state_A(_pack);
  >                 cur_State = type_B;
  >                 break;
  >             case type_B:
  >                 process_package_state_B(_pack);
  >                 cur_State = type_C;
  >                 break;
  >         }
  >     }
  >     
  > }
  > ```
  >
  > 对于不同的状态表示，这里用到了 enum 类型

- 由于后面还有很多成员变量，先定义一个函数用来初始化，该函数在初始化连接时被调用；

- process_read：

  - 设定状态机初始状态，同时需要一个成员变量标识主状态机当前所处状态；
  - 状态机循环判断：
    - 主状态机状态为请求体，并且从状态机请求成功
    - 或者：由于会对每一行解析（parse_line），这里就要就要判断从状态机每一行的解析结果是否成功；
  - 进入 while 循环就获取一行数据，这里使用一个成员变量标识正在解析的行（m_start_line），我们用一个函数来返回该行的起始；
    - 其实我们用了一个数组（读缓冲区）保存数据，而 HTTP 请求报文中每一行结尾有 `\r\n` ，所以 m_start_line 就是 `\n` 的下一个下标，每读一行我们都要更新该下标，那我们可以用一个成员变量（m_checked_idx）记录当前正在解析的字符的下标。
  - 接下来利用状态机，对主状态机进行状态转换：
    - 请求首行：判断请求是否错误
    - 请求头部：
      1. 判断请求是否错误
      2. 是否获得一个完整的客户请求，是就执行具体分析（do_request：获取服务器资源）
    - 请求体：
      1. 是否获得一个完整的客户请求，是对请求进行响应（do_request）
      2. 否就改变从状态机状态为行不完整（LINE_OPEN）
    - 服务器内部错误

- parse_line：解析一行数据，判断依据是 `\r\n`

  - 注意有个成员变量（m_read_idx）表示读缓冲区最后一个字节的下一个位置；
  - 注意字符串以 `\0` 结尾；
  - 遍历读缓冲区，遇到 `\r`：
    - 下一个字符是缓冲区结尾（m_read_idx），返回数据不完整；
    - 下一个字符是 `\n`，返回该行完整；
    - 否则返回行错误。
  - 遇到 `\n`：
    - 前面一个字符是 `\r` 的时候，该行才完整；
    - 否则该行不完整

- parse_request_line：

  - 解析 HTTP 请求首行，获得请求方法、目标 URL、HTTP版本，放到成员变量中。注意初始化。

  - ```c
    char *strpbrk(const char *str1, const char *str2);
    /*
    依次检验字符串s1中的字符，当被检验字符在字符串s2中也包含时，则停止检验，并返回该字符位置，空字符null不包括在内
    返回s1中第一个满足条件的字符的指针，如果没有匹配字符则返回空指针NULL。
    */
    ```

  - ```c
    char *strchr(const char *str, int c);
    /*
    在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置，如果未找到该字符则返回 NULL
    */
    ```

- parse_header：

  - 解析头部，获得主机名(host)、连接状态(Connection)、消息体长度(Content-Length)，并判断是否有消息体，有消息体需要改变状态。

  - ```c
    size_t strspn (const char *s,const char * accept);
    //返回字符串s开头连续包含字符串accept内的字符数目
    ```

- parse_content：该函数判断消息体是否被完整读入，没有去解析消息体。

- do_request：

  - 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，如果目标文件存在、对所有用户可读，且不是目录，则使用 mmap 将其映射到内存地址 m_file_address 处，并告诉调用者获取文件成功。
  - 给客户端响应，需要将响应存储在写缓冲区中，像读缓冲区一样，也给写缓冲区一个下标标识（m_write_idx），用一个静态变量设置写缓冲区大小；
  - 客户端会请求文件，将文件路径存入数组中，该数组存放的是文件的完整路径，注意先指定文件的根目录；
  - 我们需要对文件属性进行分析（用 C 中的结构体 struct stat），如果能够返回该文件，将该文件写入映射的内存中，用 writev 函数来执行写操作，这里用 C 中的结构体（struct iovec），其指向要写入的数据的地址和数据大小，还用了一个成员变量 m_iv_count 表示被写内存块的数量，因为 writev 采用了分散写的方法。
  - 获取文件路径及其属性，判断文件的访问权限、是否是目录；通过判断则以只读方式打开文件；创建内存映射，并将该文件映射到内存中。
  - 注意打开了文件后要关闭。

- unmap：由于创建了内存映射，在使用完内存映射后要将其释放。

- process_write：根据服务器处理HTTP请求的结果，决定返回给客户端的内容。

  - 用一些字符串，根据不同的状态码，确定不同的响应信息；
  - 响应消息也有响应首行、响应头部、响应消息体，我们通过函数将它们加入响应中。可以将加入的每一行内容都写成一个函数调用。
  - 这个函数中确定了要发送的数据长度：bytes_to_send

- add_response：

  - ```c
    void va_start(va_list argptr, last_parm);
    //读取可变参数的过程其实就是在堆栈中，使用指针,遍历堆栈段中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程·
    ```

  - ```c
    int _vsnprintf(char* str, size_t size, const char* format, va_list ap);
    //将可变参数格式化输出到一个字符数组。
    ```

  - ```c
    void va_end(va_list argptr);
    //最后取完所有参数并从函数返回之前。必须调用va_end()。由此确保堆栈的正确恢复。
    //如果未正确使用va_end()，程序可能瘫痪。
    ```

- write：

  - 定义两个成员变量表示将要发送的数据（bytes_to_send，之前已定义过）和已经发送的数据（bytes_have_send）。

  - 判断 bytes_to_send 是否为 0，是 0 则表示这一次响应结束，修改监听描述符为可读，并调用初始化成员变量函数（不带参数的 init），返回；

  - 还有要发送的数据，死循环执行分散写操作，直到没有要发送的数据。

    - 注意 writev 返回 -1 和产生错误号的情况

    - writev：一次写，免除了多次系统调用或复制数据的开销。

    - ```c
      ssize_t writev(int fd, const struct iovec *iov, int cnt);
      //writev将多个数据存储在一起，将驻留在两个或更多的不连接的缓冲区中的数据一次写出去。
      //返回值：成功返回传输字节数，失败返回-1.
      ```

    - 若响应头发送完毕，修改 m_iv；

    - 若响应头没有发送完毕，修改 m_iv 为下次写数据的位置；

    - 判断数据是否全部发送出去，若没有要发送的数据了，释放创建的内存映射，修改监听事件为可读

      - 如果连接依然保持，初始化成员变量，返回 true
      - 否则返回 false。